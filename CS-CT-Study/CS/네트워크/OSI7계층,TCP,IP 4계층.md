# 네트워크  정리 + 실전 (상세판)

> 나중에 다시 봐도 이해할 수 있도록 상세하게 정리
> 

---

## 📋 목차

1. [필수 개념 완벽 정리](about:blank#%ED%95%84%EC%88%98-%EA%B0%9C%EB%85%90-%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC)
2. [실전 시나리오](about:blank#%EC%8B%A4%EC%A0%84-%EB%A9%B4%EC%A0%91-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4)
3. [마지막 체크리스트](about:blank#%EB%A7%88%EC%A7%80%EB%A7%89-%EC%B2%B4%ED%81%AC%EB%A6%AC%EC%8A%A4%ED%8A%B8)

---

## 필수 개념 완벽 정리

### 1. OSI 7계층 - 제대로 이해하기

### 전체 구조

```
응용 계층 (Application)     ─┐
표현 계층 (Presentation)     ├─ 데이터 처리/변환
세션 계층 (Session)          ─┘
─────────────────────────────────
전송 계층 (Transport)        ─── 신뢰성, 포트 번호
─────────────────────────────────
네트워크 계층 (Network)       ─── 경로 설정, IP 주소
─────────────────────────────────
데이터링크 계층 (Data Link)   ─── 직접 연결, MAC 주소
물리 계층 (Physical)         ─── 전기 신호
```

### 7계층 - 응용 계층 (Application Layer)

**역할**: 사용자가 네트워크에 접근할 수 있게 해주는 인터페이스

**주요 프로토콜과 동작**:

```
HTTP/HTTPS: 웹 브라우징
- HTTP: 평문 통신 (포트 80)
- HTTPS: TLS 암호화 (포트 443)
- 메서드: GET, POST, PUT, DELETE 등

FTP: 파일 전송
- 제어 연결(21번), 데이터 연결(20번) 분리
- Active/Passive 모드

SMTP: 이메일 전송 (포트 25)
POP3: 이메일 수신 (포트 110)
IMAP: 이메일 관리 (포트 143)

DNS: 도메인 → IP 변환
- UDP 53번 포트 (기본)
- 512바이트 초과 시 TCP 사용
```

**PDU**: Data/Message

**실무 포인트**:
- 대부분의 프로그래밍이 이 계층에서 이루어짐
- Socket API를 통해 하위 계층 추상화
- 개발자가 가장 많이 다루는 계층

---

### 6계층 - 표현 계층 (Presentation Layer)

**역할**: 데이터 형식 변환, 암호화/복호화, 압축

**주요 기능**:

```
1. 데이터 인코딩/디코딩
   - ASCII, EBCDIC, UTF-8 변환
   - 리틀엔디안 ↔ 빅엔디안 변환

2. 암호화/복호화
   - SSL/TLS: 공개키 + 대칭키 암호화
   - 인증서 검증

3. 데이터 압축
   - JPEG, MPEG, GIF 등
   - gzip 압축

4. 직렬화
   - JSON, XML, Protocol Buffers
   - 객체 → 바이트 스트림 변환
```

**실무 예시**:

```jsx
// 표현 계층의 역할const data = { user: "kim", age: 25 };const json = JSON.stringify(data);  // 직렬화const encrypted = encrypt(json);     // 암호화// → 전송 계층으로
```

---

### 5계층 - 세션 계층 (Session Layer)

**역할**: 통신 세션의 생성, 유지, 종료 관리

**주요 기능**:

```
1. 세션 설정 및 해제
   - 연결 시작, 종료 시점 관리

2. 동기화 (Synchronization)
   - 체크포인트 설정
   - 대용량 파일 전송 중 중단 시 이어받기

3. 대화 제어
   - 반이중(Half-duplex): 한쪽씩 전송
   - 전이중(Full-duplex): 동시 양방향 전송
```

**실무 예시**:

```
WebSocket:
- 한번 연결하면 계속 유지 (세션 유지)
- 양방향 실시간 통신
- Heartbeat로 세션 생존 확인

FTP REST 명령:
- 파일 전송 중단 시 위치 기억
- 재연결 시 이어서 다운로드
```

---

### 4계층 - 전송 계층 (Transport Layer)

**역할**: 종단 간(end-to-end) 신뢰성 있는 데이터 전송

**핵심 개념**:

**1. 포트 번호로 애플리케이션 구분**

```
- 0~1023: Well-known (시스템 예약)
  HTTP(80), HTTPS(443), SSH(22), DNS(53), MySQL(3306)

- 1024~49151: Registered (등록된 서비스)
  개발자가 사용 가능하지만 충돌 주의

- 49152~65535: Dynamic (임시 포트)
  클라이언트가 사용, OS가 자동 할당
```

**2. TCP의 주요 기능**

```
신뢰성 보장:
- 순서 보장 (Sequence Number)
- 오류 검출 및 재전송
- 중복 제거

흐름 제어 (Flow Control):
- 수신자의 처리 속도 고려
- 슬라이딩 윈도우 (rwnd)

혼잡 제어 (Congestion Control):
- 네트워크 상태 고려
- Slow Start, Congestion Avoidance, Fast Retransmit/Recovery

연결 관리:
- 3-way handshake (연결)
- 4-way handshake (종료)
```

**3. UDP의 특징**

```
장점:
- 빠름 (오버헤드 최소)
- 단순함 (헤더 8바이트)
- 브로드캐스트/멀티캐스트 가능

단점:
- 신뢰성 없음
- 순서 보장 안 됨
- 애플리케이션이 직접 처리해야 함

사용 예:
- DNS: 빠른 조회, 실패 시 재시도 간단
- 스트리밍: 실시간성 중요, 약간 손실 OK
- 게임: 최신 상태만 중요, 과거 데이터 무의미
```

**PDU**: Segment (TCP), Datagram (UDP)

---

### 3계층 - 네트워크 계층 (Network Layer)

**역할**: 패킷의 경로 설정 (라우팅)

**핵심 개념**:

**1. IP 주소**

```
IPv4: 32비트 (192.168.0.1)
- 네트워크 부분 + 호스트 부분
- 서브넷 마스크로 구분
- 예: 192.168.0.0/24 → 256개 주소

IPv6: 128비트 (2001:0db8:85a3::8a2e:0370:7334)
- 주소 고갈 문제 해결
- 자동 설정, 보안 기능 내장
```

**2. 라우팅**

```
라우팅 테이블:
목적지 네트워크 | 다음 홉 | 인터페이스 | 메트릭
192.168.1.0/24  | 10.0.0.1| eth0       | 10

라우팅 알고리즘:
- 거리 벡터 (RIP): Bellman-Ford
- 링크 상태 (OSPF): Dijkstra
- 경로 벡터 (BGP): 정책 기반
```

**3. IP 단편화 (Fragmentation)**

```
패킷 크기 > MTU일 때:
┌─────────────────┐
│ 원본 패킷 (2000) │
└─────────────────┘
         ↓
┌────────┬────────┐
│조각1   │조각2   │
│(1500)  │(500)   │
└────────┴────────┘

문제점:
- 한 조각만 손실돼도 전체 재전송
- 라우터 부하 증가
- 보안 문제 (Fragment Attack)

해결:
- Path MTU Discovery
- MSS 조정으로 단편화 방지
```

**PDU**: Packet

**주요 프로토콜**:
- IP: 주소 지정, 라우팅
- ICMP: 오류 보고, ping, traceroute
- ARP: IP → MAC 주소 변환
- IGMP: 멀티캐스트 그룹 관리

---

### 2계층 - 데이터링크 계층 (Data Link Layer)

**역할**: 직접 연결된 노드 간 신뢰성 있는 전송

**핵심 개념**:

**1. MAC 주소**

```
48비트 물리 주소: AA:BB:CC:DD:EE:FF
├─ OUI (24비트): 제조사 식별
└─ NIC (24비트): 기기 고유 번호

특징:
- NIC에 하드웨어적으로 할당
- 로컬 네트워크에서만 유효
- 라우터를 지날 때마다 변경
```

**2. 스위치 동작**

```
MAC 주소 테이블:
MAC 주소        | 포트 | 에이징 타임
AA:BB:CC:DD:EE:FF | 1   | 300초

동작 과정:
1. Learning: 프레임 출발지 MAC → 포트 매핑 학습
2. Forwarding: 목적지 MAC 테이블에 있으면 해당 포트로
3. Flooding: 목적지 MAC 모르면 전체 포트로 (브로드캐스트)
4. Filtering: 불필요한 트래픽 차단
5. Aging: 오래된 엔트리 삭제 (보통 300초)
```

**3. 충돌 감지 (CSMA/CD - 유선)**

```
Carrier Sense: 전송 전 매체 확인
Multiple Access: 여러 노드가 매체 공유
Collision Detection: 충돌 감지

충돌 발생 시:
1. Jam 신호 전송 (충돌 알림)
2. 전송 중단
3. Binary Exponential Backoff
   - 1차: 0~1 슬롯 중 랜덤 대기
   - 2차: 0~3 슬롯 중 랜덤 대기
   - 3차: 0~7 슬롯...
4. 재전송

현대 이더넷: 전이중(Full-duplex) 사용으로 충돌 없음
```

**PDU**: Frame

**프레임 구조**:

```
[Preamble][목적지 MAC][출발지 MAC][타입][데이터][FCS]
    7B         6B          6B        2B   46~1500B  4B
                                              ↑
                                            MTU 1500
```

---

### 1계층 - 물리 계층 (Physical Layer)

**역할**: 비트를 전기/광/전파 신호로 변환하여 전송

**전송 매체**:

```
유선:
- UTP 케이블 (Cat5e, Cat6): ~10Gbps, ~100m
- 광섬유: ~100Gbps, 수십 km
  - 단일모드: 장거리
  - 다중모드: 단거리

무선:
- Wi-Fi (802.11): 2.4GHz, 5GHz
- Bluetooth: 2.4GHz, 단거리
- LTE/5G: 이동통신
```

**신호 변조**:

```
디지털 → 아날로그:
- ASK (Amplitude Shift Keying): 진폭 변조
- FSK (Frequency Shift Keying): 주파수 변조
- PSK (Phase Shift Keying): 위상 변조
- QAM: 진폭 + 위상 조합 (Wi-Fi, LTE)
```

**PDU**: Bit

**장비**: 케이블, 허브, 리피터, 모뎀

---

### OSI vs TCP/IP 매핑

```
OSI 7계층          TCP/IP 4계층       실제 프로토콜
─────────────────────────────────────────────────
응용 계층  ┐
표현 계층  ├────→  응용 계층  ────→  HTTP, FTP, DNS
세션 계층  ┘
─────────────────────────────────────────────────
전송 계층  ────→  전송 계층  ────→  TCP, UDP
─────────────────────────────────────────────────
네트워크 계층────→  인터넷 계층────→  IP, ICMP, ARP
─────────────────────────────────────────────────
데이터링크 ┐
물리 계층  └────→  네트워크 ────→  Ethernet, Wi-Fi
                   인터페이스
```

**왜 TCP/IP를 더 많이 쓰나?**
- OSI: 이론적 참조 모델, 복잡함
- TCP/IP: 실용적, 인터넷 표준, 단순함

---

### 2. TCP vs UDP - 완벽 비교

### TCP (Transmission Control Protocol)

**핵심 특징**:

**1. 연결 지향 (Connection-Oriented)**

```
연결 수립: 3-way handshake
데이터 전송: 양방향 독립적 스트림
연결 종료: 4-way handshake

상태 관리:
CLOSED → LISTEN → SYN_SENT → SYN_RECEIVED
→ ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2
→ TIME_WAIT → CLOSED
```

**2. 신뢰성 보장 메커니즘**

```
순서 보장:
- Sequence Number (32비트, 바이트 단위)
- 순서 바뀐 패킷 재정렬

오류 검출:
- Checksum (헤더 + 데이터 + 의사 헤더)
- 오류 발견 시 패킷 폐기

재전송:
1. 타임아웃 재전송
   - RTO (Retransmission Timeout) 초과 시
   - 지수 백오프 (1초 → 2초 → 4초...)

2. Fast Retransmit
   - 3 duplicate ACK 즉시 재전송
   - 타임아웃 기다리지 않음

중복 제거:
- Sequence Number로 중복 패킷 감지
```

**3. 흐름 제어 (Flow Control)**

```
목적: 수신자가 처리할 수 있는 속도로 전송

슬라이딩 윈도우:
송신 버퍼:
[ACK받음][전송했지만 ACK 대기][전송 가능][대기]
          └────────┬─────────┘
              송신 윈도우

수신 버퍼:
[앱에 전달][받았지만 미전달][수신 가능][불가]
          └──────┬──────┘
            수신 윈도우

윈도우 크기 계산:
rwnd = 버퍼 크기 - (NextByteExpected - LastByteRead)

Zero Window:
- 수신 버퍼 가득참 → rwnd = 0
- 송신자 전송 멈춤
- Window Probe (1바이트) 주기적 전송
```

**4. 혼잡 제어 (Congestion Control)**

```
목적: 네트워크 혼잡 방지

알고리즘 4단계:

① Slow Start:
   cwnd = 1 MSS
   ACK 받을 때마다: cwnd = cwnd × 2 (지수 증가)
   1 → 2 → 4 → 8 → 16...
   ssthresh 도달까지

② Congestion Avoidance:
   RTT마다: cwnd = cwnd + 1 (선형 증가)
   16 → 17 → 18 → 19...
   패킷 손실 감지까지

③ Fast Retransmit:
   3 duplicate ACK 수신
   → 타임아웃 기다리지 않고 즉시 재전송

④ Fast Recovery:
   ssthresh = cwnd / 2
   cwnd = ssthresh + 3
   → Congestion Avoidance로 복귀

실제 전송량 = min(rwnd, cwnd)
```

**TCP 헤더 구조** (20~60바이트):

```
 0                   16                  31
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   출발지 포트 (16)  |   목적지 포트 (16)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        시퀀스 번호 (32비트)              |  ← 바이트 위치!
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        ACK 번호 (32비트)                |  ← 다음 받을 번호!
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|헤더|예약|U|A|P|R|S|F|   윈도우 크기    |
|길이|(6)|R|C|S|S|Y|I|      (16)        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   체크섬 (16)      |  긴급 포인터 (16)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             옵션 (가변)                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

플래그 6비트:
URG (Urgent): 긴급 데이터 (거의 안 씀)
ACK (Acknowledgment): 확인응답 (거의 항상 1)
PSH (Push): 버퍼링 없이 즉시 전달
RST (Reset): 연결 강제 종료
SYN (Synchronize): 연결 시작
FIN (Finish): 연결 종료
```

**주요 옵션**:

```
MSS (Maximum Segment Size):
- TCP 데이터의 최대 크기
- SYN에서만 협상
- 일반적으로 1460바이트 (= MTU 1500 - IP 20 - TCP 20)

Window Scale:
- 윈도우 크기 확장 (최대 1GB)
- Scale Factor: 0~14
- 실제 윈도우 = Window × 2^(Scale)

SACK (Selective ACK):
- 받은 구간을 비트맵으로 표시
- 효율적 재전송

Timestamp:
- RTT 측정
- PAWS (시퀀스 번호 재사용 방지)
```

---

### UDP (User Datagram Protocol)

**핵심 특징**:

**1. 비연결 (Connectionless)**

```
연결 설정 없음:
- 3-way handshake 불필요
- 바로 데이터 전송
- 오버헤드 최소화

상태 없음:
- 연결 정보 유지 안 함
- 서버 리소스 절약
```

**2. 신뢰성 없음 (Unreliable)**

```
보장 안 함:
- 전송 보장 안 함 (Fire and Forget)
- 순서 보장 안 함
- 오류 검출만 함 (정정은 안 함)

재전송 없음:
- 패킷 손실 시 그냥 버림
- 애플리케이션이 처리해야 함
```

**3. 단순함**

```
헤더 8바이트 (고정):
 0                   16                  31
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   출발지 포트 (16)  |   목적지 포트 (16)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     길이 (16)      |    체크섬 (16)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

길이: UDP 헤더 + 데이터 (최소 8, 최대 65535)
체크섬: 선택적 (IPv4), 필수 (IPv6)
```

**4. 브로드캐스트/멀티캐스트**

```
유니캐스트: 1:1
브로드캐스트: 1:전체 (255.255.255.255)
멀티캐스트: 1:그룹 (224.0.0.0/4)

TCP는 연결 지향이라 불가능
UDP는 비연결이라 가능
```

---

### TCP vs UDP 완전 비교

| 특징 | TCP | UDP |
| --- | --- | --- |
| **연결** | 연결 지향 (3-way) | 비연결 |
| **신뢰성** | 보장 (재전송, 순서) | 보장 안 함 |
| **순서** | 보장 | 무관 |
| **속도** | 느림 (오버헤드 큼) | 빠름 |
| **헤더** | 20~60바이트 | 8바이트 (고정) |
| **흐름 제어** | O (슬라이딩 윈도우) | X |
| **혼잡 제어** | O (4단계 알고리즘) | X |
| **오류 처리** | 검출 + 재전송 | 검출만 (폐기) |
| **브로드캐스트** | X | O |
| **연결 수** | 1:1 | 1:1, 1:N, N:N |
| **오버헤드** | 큼 (연결 관리, 재전송 등) | 작음 |
| **버퍼링** | O | X |

---

### 사용 예시와 이유

**TCP 사용**:

```
1. 웹 브라우징 (HTTP/HTTPS):
   - 페이지 내용이 하나라도 손실되면 안 됨
   - 순서대로 표시해야 함

2. 파일 전송 (FTP, SCP):
   - 파일 무결성 필수
   - 1바이트라도 손실되면 파일 손상

3. 이메일 (SMTP, IMAP):
   - 메일 내용 손실 불가
   - 첨부파일 무결성

4. 원격 접속 (SSH, Telnet):
   - 명령어 정확히 전달
   - 순서 중요

5. 데이터베이스 쿼리:
   - 쿼리 결과 정확성
   - 트랜잭션 보장
```

**UDP 사용**:

```
1. DNS 조회:
   - 데이터 작음 (보통 512바이트 이하)
   - 빠른 응답 필요
   - 실패하면 재요청 간단

2. 실시간 스트리밍:
   - 실시간성이 최우선
   - 약간의 프레임 손실은 괜찮음
   - 재전송하면 이미 지나간 시간 (무의미)
   - 예: YouTube Live, Netflix, Twitch

3. 온라인 게임:
   - 낮은 지연(latency)이 중요
   - 최신 위치 정보만 의미 있음
   - 과거 위치는 무의미
   - 초당 20~60회 업데이트

4. VoIP (화상/음성 통화):
   - 실시간 대화
   - 약간의 끊김은 괜찮음
   - 재전송은 대화 흐름 방해

5. IoT 센서:
   - 센서 데이터 주기적 전송
   - 최신 데이터만 중요
   - 가벼운 프로토콜 필요

6. DHCP (IP 주소 할당):
   - 브로드캐스트 필요
   - 간단한 요청/응답

7. NTP (시간 동기화):
   - 빠른 응답 필요
   - 가벼운 프로토콜
```

---

```

```

---

### 3. 3-way Handshake - 완벽 분석

### 전체 흐름

```
클라이언트 (능동 개방)      서버 (수동 개방)
     |                         |
  CLOSED                    LISTEN
     |                         |
     |    [1] SYN              |
     |    SEQ=X (랜덤 ISN)     |
     |------------------------>|
 SYN_SENT                      |
     |                         |
     |                   (SYN 수신)
     |                   Backlog Queue 추가
     |                         |
     |    [2] SYN+ACK          |
     |    SEQ=Y, ACK=X+1       |
     |<------------------------|
     |                   SYN_RECEIVED
     |                         |
  (SYN+ACK 수신)               |
     |                         |
     |    [3] ACK              |
     |    SEQ=X+1, ACK=Y+1     |
     |------------------------>|
ESTABLISHED                    |
     |                   (ACK 수신)
     |                         |
     |                   ESTABLISHED
     |<-- 데이터 통신 시작 -->|
```

---

### 단계별 상세 분석

**[1단계] SYN - 연결 요청**

**패킷 내용**:

```
TCP 헤더:
- 출발지 포트: 52345 (클라이언트 임시 포트)
- 목적지 포트: 80 (HTTP 서버)
- 시퀀스 번호: 1000 (랜덤 ISN)
- ACK 번호: 0 (아직 받은 것 없음)
- 플래그: SYN=1, ACK=0
- 윈도우 크기: 65535
- 옵션:
  - MSS: 1460
  - Window Scale: 7 (128배)
  - SACK Permitted
  - Timestamp
```

**의미**:
> “서버야, 나(클라이언트)랑 TCP 연결하고 싶어!

> 내 시작 시퀀스 번호는 1000이야.

> 내 수신 윈도우는 65535바이트야.”

**클라이언트 상태 변화**:

```
CLOSED (socket() 직후)
  ↓
connect() 호출
  ↓
SYN 패킷 전송
  ↓
SYN_SENT (SYN 응답 대기)
```

**서버 동작**:

```
1. SYN 패킷 수신
2. 포트 80번에 LISTEN 중인지 확인
3. Backlog Queue에 half-open 연결 추가
4. SYN+ACK 패킷 준비
```

**ISN (Initial Sequence Number) 선택**:

```
왜 랜덤?
- 보안: TCP Sequence Prediction Attack 방지
- 충돌 방지: 이전 연결의 지연 패킷 구분

생성 방법 (RFC 6528):
ISN = M + F(localhost, localport, remotehost, remoteport, secret)
M: 4ms마다 1씩 증가하는 타이머
F: 암호학적 해시 함수
```

---

**[2단계] SYN+ACK - 연결 수락**

**패킷 내용**:

```
TCP 헤더:
- 출발지 포트: 80
- 목적지 포트: 52345
- 시퀀스 번호: 3000 (서버의 랜덤 ISN)
- ACK 번호: 1001 (클라이언트 SEQ + 1)
- 플래그: SYN=1, ACK=1
- 윈도우 크기: 43690
- 옵션:
  - MSS: 1460
  - Window Scale: 8 (256배)
  - SACK Permitted
  - Timestamp
```

**의미**:
> “오케이! 너(클라이언트)의 SYN(1000) 잘 받았어. (ACK=1001)

> 나(서버)도 연결 준비 됐어! (SYN)

> 내 시작 시퀀스 번호는 3000이야.

> 내 수신 윈도우는 43690바이트야.”

**서버 상태 변화**:

```
LISTEN
  ↓
SYN 수신
  ↓
SYN_RECEIVED (클라이언트 ACK 대기)
```

**옵션 협상**:

```
MSS 협상:
- 클라이언트: 1460
- 서버: 1460
- 사용: min(1460, 1460) = 1460

Window Scale 협상:
- 클라이언트: 7 (128배)
- 서버: 8 (256배)
- 각자 받은 값 사용
  - 클라이언트는 서버 윈도우를 256배로 해석
  - 서버는 클라이언트 윈도우를 128배로 해석
```

---

**[3단계] ACK - 연결 확정**

**패킷 내용**:

```
TCP 헤더:
- 출발지 포트: 52345
- 목적지 포트: 80
- 시퀀스 번호: 1001 (이전 SEQ + SYN 소비 1)
- ACK 번호: 3001 (서버 SEQ + SYN 소비 1)
- 플래그: SYN=0, ACK=1
- 윈도우 크기: 65535
```

**의미**:
> “서버야, 너의 SYN+ACK(3000) 잘 받았어!

> 3001번부터 보내줘. 이제 데이터 주고받자!”

**양쪽 상태 변화**:

```
클라이언트: SYN_SENT → ESTABLISHED
서버: SYN_RECEIVED → ESTABLISHED (accept() 반환)
```

**연결 확립**:

```
이제 양방향 데이터 전송 가능:

클라이언트 → 서버:
- SEQ는 1001부터 시작
- 100바이트 전송 → 다음 SEQ = 1101

서버 → 클라이언트:
- SEQ는 3001부터 시작
- 200바이트 전송 → 다음 SEQ = 3201

각자 독립적인 시퀀스 공간 유지
```

---

### 왜 2-way가 아니라 3-way인가?

**2-way 시도 시 문제점**:

**문제 1: 서버 준비 상태 미확인**

```
시나리오:
1. 클라이언트 → 서버: SYN
2. 서버 → 클라이언트: SYN+ACK

여기서 끝?

문제:
- SYN+ACK가 손실되면?
- 클라이언트는 서버가 준비됐는지 모름
- 데이터 보내면 서버는 "무슨 연결?" → RST

해결:
- 3번째 ACK로 서버 준비 최종 확인
```

**문제 2: 지연된 SYN 문제 (Old Duplicate SYN)**

```
시나리오:
1. 클라이언트 SYN 전송 → 네트워크 지연
2. 클라이언트 타임아웃 → 재전송
3. 두 번째 SYN으로 연결 성공 → 데이터 통신 → 정상 종료
4. 첫 번째 SYN이 뒤늦게 도착
   → 서버가 새 연결로 착각! (2-way면)
   → 불필요한 연결 생성

해결:
- 3-way에서는 마지막 ACK 없으면 서버가 연결 확정 안 함
- 지연된 SYN의 SEQ가 맞지 않으면 RST 전송
```

**문제 3: 양방향 통신 보장 부족**

```
TCP는 전이중(Full-Duplex) 통신:
- 클라이언트 → 서버 (확인 필요)
- 서버 → 클라이언트 (확인 필요)

2-way:
- 클라이언트 → 서버: SYN으로 확인
- 서버 → 클라이언트: 미확인!

3-way:
- SYN: 클라이언트 → 서버 테스트
- SYN+ACK: 서버 → 클라이언트 테스트
- ACK: 양방향 확인 완료
```

```
방화벽이 중간에서:
1. 클라이언트와 3-way handshake 완료
2. 성공하면 서버와 연결
3. 실패한 SYN은 서버에 안 전달

장점:
- 서버 보호
- 정상 사용자만 통과

단점:
- 방화벽 부하
- 지연 증가 (2× RTT)
```

---

---

### TCP Fast Open (TFO)

**문제: 3-way handshake의 RTT 오버헤드**

```
전통적 TCP:
Client                Server
  |                     |
  |---SYN-------------->| (RTT)
  |<--SYN+ACK-----------|
  |---ACK-------------->|
  |---Data (HTTP GET)-->| (RTT)
  |<--Data (HTTP Resp)--|

총 2 RTT 후 데이터 전송
```

**TFO 해결책**:

```
첫 연결:
Client                Server
  |                     |
  |---SYN-------------->| (TFO 쿠키 요청)
  |<--SYN+ACK + Cookie--|
  |---ACK-------------->|
  (쿠키 저장)

재연결 (0-RTT):
Client                Server
  |                     |
  |---SYN + Cookie---->| (데이터 포함!)
  |   + Data (HTTP GET) |
  |<--SYN+ACK + Data----|
  |   (HTTP Response)   |
  |---ACK-------------->|

1 RTT 절약! (데이터가 SYN과 함께 전송)
```

**TFO 쿠키 생성**:

```
Cookie = AES(서버 비밀키, 클라이언트 IP)

특징:
- 클라이언트 IP 기반
- 서버만 검증 가능
- 재사용 가능 (일정 기간)
```

**TFO 제약사항**:

```
안전한 요청만:
- Idempotent 요청 (GET, HEAD)
- POST는 위험 (재시도 시 부작용)
- 예: 결제 요청을 TFO로 보내면 중복 결제 가능

재전송 문제:
- SYN이 손실되면 재전송
- 데이터도 재전송 → 중복 처리 위험
```

---

### 4. 4-way Handshake - 완벽 분석

### 전체 흐름

```
클라이언트 (능동 종료)      서버 (수동 종료)
     |                         |
ESTABLISHED                ESTABLISHED
     |                         |
     |    [1] FIN              |
     |    SEQ=X                |
     |------------------------>|
 FIN_WAIT_1                    |
     |                   (FIN 수신)
     |                         |
     |    [2] ACK              |
     |    ACK=X+1              |
     |<------------------------|
 FIN_WAIT_2              CLOSE_WAIT
     |                         |
     |              (애플리케이션 종료 대기)
     |              (남은 데이터 전송...)
     |                         |
     |    [3] FIN              |
     |    SEQ=Y                |
     |<------------------------|
  TIME_WAIT               LAST_ACK
     |                         |
     |    [4] ACK              |
     |    ACK=Y+1              |
     |------------------------>|
  TIME_WAIT                 CLOSED
     |                         |
  (2MSL 대기)                  |
  약 60~120초                  |
     |                         |
   CLOSED                      |
```

---

### 단계별 상세 분석

**[1단계] FIN - 종료 요청**

**패킷 내용**:

```
TCP 헤더:
- 출발지 포트: 52345
- 목적지 포트: 80
- 시퀀스 번호: 5000
- ACK 번호: 8000 (계속 확인응답)
- 플래그: FIN=1, ACK=1
- 윈도우 크기: 65535
```

**의미**:
> “서버야, 나(클라이언트)는 더 이상 보낼 데이터가 없어.

> 송신 방향을 종료하고 싶어.

> (하지만 수신은 아직 가능해!)”

**클라이언트 동작**:

```
애플리케이션: close() 또는 shutdown(SHUT_WR)
  ↓
송신 버퍼 비우기 (남은 데이터 전송)
  ↓
FIN 패킷 전송 (FIN도 1바이트 소비)
  ↓
FIN_WAIT_1 상태 (서버 ACK 대기)
```

**중요 개념: Half-Close**

```
클라이언트:
- 송신: 종료 (FIN 전송)
- 수신: 가능 (서버가 아직 보낼 수 있음)

이 상태를 Half-Close라고 함
```

---

**[2단계] ACK - 종료 확인**

**패킷 내용**:

```
TCP 헤더:
- 출발지 포트: 80
- 목적지 포트: 52345
- 시퀀스 번호: 8000
- ACK 번호: 5001 (FIN도 1바이트 소비)
- 플래그: ACK=1
- 윈도우 크기: 43690
```

**의미**:
> “클라이언트야, 너의 FIN 잘 받았어.

> 나(서버)는 알겠는데, 아직 보낼 데이터가 있을 수 있어.

> 잠깐만 기다려줘!”

**클라이언트 상태**:

```
FIN_WAIT_1 → FIN_WAIT_2
- ACK 받음 (서버가 FIN 인지함)
- 서버의 FIN 대기 중
```

**서버 상태**:

```
ESTABLISHED → CLOSE_WAIT
- 클라이언트가 종료 요청했음을 인지
- 애플리케이션에 알림 (read()가 0 반환)
- 아직 데이터 보낼 수 있음
```

**실제 시나리오**:

```
HTTP 응답 예시:

클라이언트: "GET /largefile.zip" → FIN
서버: ACK (요청 받았어)
서버: 200 OK
서버: [파일 데이터 1MB...]
서버: [파일 데이터 1MB...]  ← 아직 전송 중
서버: [파일 데이터 1MB...]
서버: FIN (다 보냈어)
클라이언트: ACK
```

---

**[3단계] FIN - 서버도 종료**

**패킷 내용**:

```
TCP 헤더:
- 출발지 포트: 80
- 목적지 포트: 52345
- 시퀀스 번호: 10000 (데이터 더 보냈다고 가정)
- ACK 번호: 5001
- 플래그: FIN=1, ACK=1
- 윈도우 크기: 43690
```

**의미**:
> “클라이언트야, 나(서버)도 이제 다 보냈어.

> 나도 연결 종료하고 싶어!”

**서버 동작**:

```
애플리케이션: close() 호출
  ↓
송신 버퍼 비우기
  ↓
FIN 패킷 전송
  ↓
CLOSE_WAIT → LAST_ACK (클라이언트 ACK 대기)
```

**클라이언트 상태**:

```
FIN_WAIT_2 → TIME_WAIT
- 서버 FIN 받음
- ACK 전송 준비
```

---

**[4단계] ACK - 최종 확인**

**패킷 내용**:

```
TCP 헤더:
- 출발지 포트: 52345
- 목적지 포트: 80
- 시퀀스 번호: 5001
- ACK 번호: 10001
- 플래그: ACK=1
- 윈도우 크기: 65535
```

**의미**:
> “서버야, 너의 FIN도 잘 받았어.

> 이제 진짜 끝!”

**서버 상태**:

```
LAST_ACK → CLOSED (즉시 종료)
- 리소스 해제
- 포트 재사용 가능
```

**클라이언트 상태**:

```
TIME_WAIT (2MSL 동안 대기)
  ↓
약 60~120초 후
  ↓
CLOSED
```

---

### TIME_WAIT 상태 - 깊이 이해하기

**TIME_WAIT이란?**

```
연결 종료 후 일정 시간(2MSL) 동안
소켓을 유지하는 상태

MSL (Maximum Segment Lifetime):
- 패킷이 네트워크에 존재할 수 있는 최대 시간
- 일반적으로 30초~2분
- 2MSL = 약 60초~4분 (리눅스 기본: 60초)
```

**왜 필요한가? - 3가지 이유**

**이유 1: 마지막 ACK 손실 대비**

```
시나리오:
Client                Server
  |                     |
  |<--FIN---------------|
  |                  LAST_ACK
  |---ACK-------------->|
TIME_WAIT              |
  |        X (ACK 손실) |
  |                     |
  |        (타임아웃)    |
  |<--FIN (재전송)------|
  |---ACK-------------->|
  |                  CLOSED

만약 TIME_WAIT 없었다면:
- 클라이언트 즉시 CLOSED
- 서버 FIN 재전송 도착
- 클라이언트 "무슨 연결?" → RST
- 서버는 비정상 종료로 인식
```

**이유 2: 지연된 패킷 처리**

```
시나리오:
1. 연결 A: 192.168.1.1:5000 ↔ 192.168.1.2:80
   - 데이터 전송 중 일부 패킷 네트워크에서 지연
   - 연결 종료

2. 즉시 같은 4-tuple로 새 연결 B 시작
   - 192.168.1.1:5000 ↔ 192.168.1.2:80 (동일!)

3. 연결 A의 지연된 패킷 도착
   - 연결 B의 데이터로 오인
   - 데이터 오염! (심각한 버그)

TIME_WAIT 덕분에:
- 2MSL 동안 같은 4-tuple 재사용 안 함
- 지연된 패킷이 모두 소멸될 때까지 대기
```

**이유 3: 4-tuple 재사용 방지**

```
4-tuple: (출발지IP, 출발지포트, 목적지IP, 목적지포트)

동일한 4-tuple 연결이 동시에 2개 존재하면:
- TCP는 패킷을 어느 연결에 속하는지 구분 못 함
- 시퀀스 번호만으로는 불충분 (wraparound 가능)

TIME_WAIT으로:
- 충분한 시간 확보
- 같은 4-tuple 연결 구분 가능
```

---

### 

```
여러 서버로 분산:
- 각 서버의 TIME_WAIT 부담 감소
- 서버 1: 50,000 TIME_WAIT
- 서버 2: 50,000 TIME_WAIT
- ...
- 총 부담은 같지만 각 서버는 여유
```

---

### 왜 3-way가 아니라 4-way인가?

**핵심: TCP는 전이중(Full-Duplex) 통신**

```
전이중 통신:
클라이언트 → 서버: 독립적인 스트림 A
서버 → 클라이언트: 독립적인 스트림 B

각 스트림을 별도로 종료해야 함
```

**ACK와 FIN이 분리되는 이유**:

```
시나리오:

클라이언트: "GET /largefile.zip HTTP/1.1" (요청 완료)
클라이언트: FIN (나는 더 안 보낼게)

서버: ACK (요청 받았어)
서버: [HTTP 응답 시작]
서버: [파일 데이터 10MB...]  ← 아직 전송 중!
서버: [파일 데이터 10MB...]
서버: [파일 데이터 10MB...]
서버: [전송 완료]
서버: FIN (나도 끝)

클라이언트: ACK (확인)

만약 3-way (ACK+FIN 동시)라면:
→ 서버가 남은 데이터를 못 보냄!
→ 파일 전송 실패!
```

**Half-Close 상태의 필요성**:

```
HTTP 예시:
1. 클라이언트가 요청 완료 → FIN
2. 서버는 ACK만 보냄 (Half-Close)
3. 서버가 대용량 응답 전송
4. 서버도 완료 → FIN
5. 클라이언트 ACK

이 과정에서:
- 클라이언트 송신: 종료
- 클라이언트 수신: 활성
- 서버 송신: 활성
- 서버 수신: 종료
```

---

### 동시 종료 (Simultaneous Close)

**양쪽이 동시에 FIN 전송**:

```
Client                Server
  |                     |
  |---FIN-------------->|
  |<--FIN---------------|
  | (교차 전송)          |
FIN_WAIT_1        FIN_WAIT_1
  |                     |
  | (양쪽 FIN 수신)      |
  |---ACK-------------->|
  |<--ACK---------------|
  |                     |
CLOSING             CLOSING
  |                     |
  | (양쪽 ACK 수신)      |
TIME_WAIT         TIME_WAIT
  |                     |
  | (2MSL 대기)         |
CLOSED              CLOSED
```

**특징**:
- 4개 패킷이지만 순서가 다름
- 양쪽 모두 TIME_WAIT 진입
- 실무에서는 드물게 발생

---

### RST (Reset) - 강제 종료

**정상 종료 vs 강제 종료**:

| 항목 | FIN (Graceful) | RST (Abortive) |
| --- | --- | --- |
| 의미 | “정중하게 종료” | “즉시 끊기” |
| 버퍼 | 모두 전송 | 버림 |
| 과정 | 4-way handshake | 즉시 종료 |
| TIME_WAIT | 발생 | 없음 |
| 데이터 | 보장 | 손실 가능 |

**RST 발생 상황**:

**1. 존재하지 않는 포트 접속**

```
Client → Server: SYN (포트 9999)
Server: "9999 포트에 리스닝 없음"
Server → Client: RST

결과: "Connection refused"
```

**2. SO_LINGER(0) 옵션**

```c
struct linger opt;opt.l_onoff = 1;opt.l_linger = 0;  // 0초 대기setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &opt, sizeof(opt));close(sockfd);동작:- 송신 버퍼 데이터 버림
- FIN 대신 RST 전송
- TIME_WAIT 없음
주의:- 상대방이 데이터 못 받을 수 있음
- 응급 상황에만 사용
```

**3. 버퍼에 데이터 남은 상태에서 close()**

```
send(sockfd, data, size, 0);
close(sockfd);  // 즉시 종료

송신 버퍼에 아직 보내지 못한 데이터:
→ RST 전송
→ 상대방은 데이터 못 받음

해결:
shutdown(sockfd, SHUT_WR);  // 송신만 종료
// 수신 버퍼 비우기
close(sockfd);  // FIN 전송
```

**4. Half-Open 연결 감지**

```
Client 비정상 종료 (전원 차단)
Server는 모름, ESTABLISHED 유지

Server → Client: 데이터 전송
Client (재부팅 후): "무슨 연결?"
Client → Server: RST

Server: 연결 오류 감지
```

---

### Half-Open 연결

**정의**:

```
한쪽은 연결이 끊어졌지만,
다른 쪽은 아직 ESTABLISHED 상태인 비정상 상황
```

**발생 원인**:

```
1. 비정상 종료:
   - 전원 차단
   - 프로세스 강제 종료 (kill -9)
   - OS 크래시

2. 네트워크 단절:
   - 케이블 뽑힘
   - 라우터 다운
   - 방화벽 규칙 변경

3. 방화벽 타임아웃:
   - 방화벽이 연결 추적 정보 삭제
   - 양쪽 호스트는 모름
```

**감지 방법**:

**1. TCP Keepalive**

```c
int opt = 1;setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt));
```

```bash
# 리눅스 설정sysctl net.ipv4.tcp_keepalive_time    # 7200초 (2시간)sysctl net.ipv4.tcp_keepalive_intvl   # 75초 (probe 간격)sysctl net.ipv4.tcp_keepalive_probes  # 9회 (재시도)
```

```
동작:
1. 7200초(2시간) 동안 데이터 송수신 없음
2. Keepalive Probe 전송 (빈 ACK 패킷)
3. 응답 없으면 75초 후 재시도
4. 9회 실패 시 연결 종료 (RST)

총 대기 시간: 2시간 + 75초×9 = 약 2시간 11분

문제:
- 너무 길음 (실시간 앱 부적합)
- 리소스 낭비
```

**2. 애플리케이션 레벨 Heartbeat (권장)**

```
WebSocket 예시:

Client                Server
  |                     |
  |---ping------------->|
  |<--pong--------------|
  |                     |
  (30초 간격)           |
  |                     |
  |---ping------------->|
  |<--pong--------------|

응답 없으면:
1. 3회 재시도
2. 연결 종료
3. 재연결 시도

총 대기: 30초×3 = 90초 (훨씬 빠름)
```

```jsx
// 클라이언트const ws = new WebSocket('ws://...');let pingInterval;ws.onopen = () => {
  pingInterval = setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type: 'ping'}));    }
  }, 30000);  // 30초};ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);  if (msg.type === 'pong') {
    // 연결 정상  }
};ws.onclose = () => {
  clearInterval(pingInterval);  // 재연결 로직};
```

---

## 실전 면접 시나리오

### 📌 시나리오 1: OSI 계층

**Q1. OSI 7계층에 대해 설명해주세요.**

```
답변:
"OSI 7계층은 네트워크 통신을 7개 계층으로 나눈 참조 모델입니다.
위에서부터 응용, 표현, 세션, 전송, 네트워크, 데이터링크, 물리 계층이고,
각 계층은 독립적으로 동작하며 하위 계층의 서비스를 사용합니다.
실무에서는 TCP/IP 4계층을 주로 사용하지만,
네트워크를 이해하는 프레임워크로 OSI 모델이 유용합니다."
```

**→ 꼬리 Q1-1. 각 계층의 대표 프로토콜을 말씀해주세요.**

```
"L7 응용: HTTP, FTP, DNS
L4 전송: TCP, UDP
L3 네트워크: IP, ICMP, ARP
L2 데이터링크: Ethernet
각 계층이 독립적이라 특정 계층만 교체 가능합니다."
```

**→ 꼬리 Q1-2. 데이터가 전송될 때 각 계층에서 어떤 일이 일어나나요?**

```
"캡슐화 과정을 거칩니다.
L7에서 Data가 생성되고,
L4에서 TCP 헤더가 붙어 Segment가 되고,
L3에서 IP 헤더가 붙어 Packet,
L2에서 Ethernet 헤더/트레일러가 붙어 Frame이 되고,
L1에서 비트로 변환되어 전송됩니다.
수신측에서는 역캡슐화가 일어납니다."
```

**→ 꼬리 Q1-3. TCP는 몇 계층이고, 왜 전송 계층이라고 하나요?**

```
"TCP는 4계층(전송 계층)입니다.
전송 계층은 종단 간(end-to-end) 신뢰성 있는 데이터 전송을 담당합니다.
포트 번호로 애플리케이션을 구분하고,
흐름 제어와 혼잡 제어를 통해 안정적인 통신을 보장합니다.
3계층(네트워크)은 호스트 간 경로를 찾지만,
4계층은 프로세스 간 통신을 보장합니다."
```

---

### 📌 시나리오 2: TCP vs UDP

**Q2. TCP와 UDP의 차이점을 설명해주세요.**

```
"TCP는 연결 지향 프로토콜로 3-way handshake로 연결을 수립하고,
신뢰성을 보장하며 순서도 보장합니다.
흐름 제어와 혼잡 제어를 수행하지만 오버헤드가 큽니다.

UDP는 비연결 프로토콜로 연결 설정 없이 바로 전송하고,
신뢰성을 보장하지 않지만 빠르고 가볍습니다.
헤더가 8바이트로 간단하며 브로드캐스트를 지원합니다.

TCP는 웹, 이메일, 파일전송에,
UDP는 스트리밍, 게임, DNS에 주로 사용됩니다."
```

**→ 꼬리 Q2-1. DNS는 왜 UDP를 사용하나요?**

```
"DNS는 여러 이유로 UDP를 사용합니다:

1. 데이터가 작습니다 (보통 512바이트 이하)
2. 빠른 응답이 필요합니다
3. 실패하면 재요청하면 되므로 신뢰성이 덜 중요합니다
4. 연결 설정 오버헤드를 피할 수 있습니다

다만 응답이 512바이트를 넘거나
Zone Transfer 같은 대용량 전송은 TCP를 사용합니다."
```

**→ 꼬리 Q2-2. 스트리밍은 왜 UDP를 사용하나요?**

```
"스트리밍은 실시간성이 최우선입니다.

패킷이 손실되어 몇 프레임이 끊겨도
사용자는 크게 불편하지 않지만,
재전송으로 인한 지연은 치명적입니다.

TCP로 재전송하면 이미 지나간 시점의 데이터라
의미가 없고, 전체 스트림이 지연됩니다.

따라서 UDP로 빠르게 전송하고,
손실된 부분은 그냥 건너뛰는 것이 더 낫습니다."
```

**→ 꼬리 Q2-3. HTTP/3는 어떤 프로토콜을 사용하나요?**

```
"HTTP/3는 QUIC을 사용하는데, QUIC은 UDP 기반입니다.

TCP의 HOL Blocking 문제를 해결하기 위해 만들어졌습니다.
HTTP/2는 TCP 기반이라 하나의 패킷 손실이
모든 스트림을 지연시키는 문제가 있었습니다.

QUIC은 UDP 위에 TCP의 신뢰성을 구현했고,
스트림별로 독립적으로 처리하며,
0-RTT 연결 재개가 가능해 더 빠릅니다."
```

---

### 📌 시나리오 3: 3-way Handshake

**Q3. 3-way handshake를 설명해주세요.**

```
답변 (그림 그리면서):
"TCP 연결 수립 과정입니다.

1단계: 클라이언트가 SYN 플래그로 연결 요청
        시퀀스 번호는 랜덤하게 선택

2단계: 서버가 SYN+ACK로 응답
        서버의 시퀀스 번호도 랜덤 선택
        클라이언트 SEQ+1을 ACK로

3단계: 클라이언트가 ACK로 확인
        서버 SEQ+1을 ACK로

이후 양쪽 모두 ESTABLISHED 상태가 되어
데이터 통신을 시작합니다."
```

**→ 꼬리 Q3-1. 왜 2-way가 아니라 3-way인가요?**

```
"TCP는 양방향 통신이므로 양쪽 모두 준비 상태를 확인해야 합니다.

2-way만 하면:
1. 서버가 준비됐는지 클라이언트가 확인할 수 없습니다
2. SYN+ACK가 손실되면 클라이언트는 모른 채 데이터를 보냅니다
3. 서버→클라이언트 방향의 통신이 가능한지 보장할 수 없습니다

3번째 ACK로 서버의 준비 상태를 최종 확인하고,
양방향 통신이 모두 가능함을 보장합니다."
```

**→ 꼬리 Q3-2. SYN 패킷도 시퀀스 번호를 소비하나요?**

```
"네, SYN이나 FIN 같은 제어 플래그도
시퀀스 번호를 1 소비합니다.

예를 들어:
클라이언트 SYN: SEQ=1000
서버 SYN+ACK: ACK=1001 (1000 + 1)

이렇게 하면 제어 메시지도 순서를 보장하고,
데이터와 구분할 수 있습니다."
```

**→ 꼬리 Q3-3. SYN Flooding 공격에 대해 설명해주세요.**

```
"SYN Flooding은 DDoS 공격의 일종입니다.

공격 방법:
- 공격자가 무수히 많은 SYN만 보내고 ACK는 보내지 않습니다
- 서버의 Backlog Queue가 가득 차서
  정상 사용자의 연결 요청이 거부됩니다

대응책:
1. SYN Cookie
   - 연결 정보를 메모리에 저장하지 않고
   - 암호학적 해시를 SYN+ACK의 SEQ에 인코딩
   - 메모리 사용 0으로 방어

2. Rate Limiting
   - 같은 IP에서 초당 SYN 개수 제한

3. SYN Proxy
   - 방화벽이 먼저 3-way handshake 검증 후
     서버에 연결 중계"
```

**→ 꼬리 Q3-4. 시퀀스 번호를 랜덤하게 선택하는 이유는?**

```
"보안상의 이유입니다.

시퀀스 번호가 예측 가능하면
TCP Sequence Prediction 공격에 취약합니다.

공격자가:
1. 시퀀스 번호 패턴을 분석하고
2. 다음 시퀀스 번호를 예측하여
3. 정상 연결로 위장한 패킷을 삽입하거나
4. 세션 하이재킹을 할 수 있습니다.

따라서 암호학적으로 안전한 난수를 사용하여
예측 불가능하게 만듭니다."
```

---

### 📌 시나리오 4: 4-way Handshake

**Q4. 4-way handshake를 설명해주세요.**

```
답변 (그림 그리면서):
"TCP 연결 종료 과정입니다.

1단계: 클라이언트가 FIN 전송 (더 이상 보낼 데이터 없음)
2단계: 서버가 ACK 응답 (FIN 수신 확인)
        서버는 아직 데이터를 보낼 수 있음 (Half-Close)
3단계: 서버가 데이터 전송 완료 후 FIN 전송
4단계: 클라이언트가 ACK 응답 후 TIME_WAIT 상태

클라이언트는 2MSL(약 60초) 대기 후 종료하고,
서버는 즉시 종료합니다."
```

**→ 꼬리 Q4-1. 왜 3-way가 아니라 4-way인가요?**

```
"TCP는 전이중(full-duplex) 통신이므로
양방향을 각각 독립적으로 종료해야 합니다.

클라이언트가 FIN을 보낸 후에도
서버는 아직 보낼 데이터가 있을 수 있습니다.

예를 들어 HTTP 요청:
- 클라이언트: 요청 완료 → FIN
- 서버: ACK (요청 받았어)
- 서버: 대용량 파일 전송 중...
- 서버: 전송 완료 → FIN

ACK와 FIN을 분리해야
서버가 남은 데이터를 보낼 수 있습니다.
이 상태를 Half-Close라고 합니다."
```

**→ 꼬리 Q4-2. TIME_WAIT은 왜 필요한가요?**

```
"TIME_WAIT이 필요한 이유는 3가지입니다:

1. 마지막 ACK 손실 대비
   - 서버의 FIN에 대한 ACK가 손실되면
   - 서버가 FIN을 재전송하는데
   - 클라이언트가 없으면 응답할 수 없습니다

2. 지연된 패킷 처리
   - 이전 연결의 패킷이 네트워크에 남아있을 수 있고
   - 새 연결에 섞이면 데이터가 오염됩니다
   - 2MSL 동안 모든 패킷이 소멸되도록 보장합니다

3. 4-tuple 재사용 방지
   - 같은 출발지IP:포트, 목적지IP:포트 조합이
   - 동시에 2개 존재하면 안 되므로
   - 충분한 시간을 확보합니다

일반적으로 2MSL(60~120초) 동안 대기합니다."
```

**→ 꼬리 Q4-3. TIME_WAIT이 실무에서 문제가 되나요?**

```
"네, 고성능 서버에서 큰 문제입니다.

문제 상황:
- 초당 수천 개의 연결 생성/종료
- 각 연결이 60초씩 TIME_WAIT
- 수만 개의 TIME_WAIT 소켓 누적
- 포트 고갈: 49152~65535 (약 16,000개)
- 메모리 낭비: 각 소켓 약 4KB

해결 방법:
1. SO_REUSEADDR 소켓 옵션
   - TIME_WAIT 포트 재사용 허용

2. tcp_tw_reuse 커널 파라미터
   - 타임스탬프로 안전하게 재사용

3. 커넥션 풀
   - 연결 재사용으로 TIME_WAIT 자체 방지

4. 서버가 능동 종료하지 않기
   - 클라이언트가 먼저 FIN 보내도록 설계
   - TIME_WAIT이 클라이언트에 생김

5. HTTP Keep-Alive
   - 연결 유지로 종료 횟수 감소"
```

**→ 꼬리 Q4-4. RST와 FIN의 차이는 무엇인가요?**

```
"FIN은 정상 종료(Graceful Shutdown)이고,
RST는 강제 종료(Abortive Shutdown)입니다.

FIN:
- 송신 버퍼의 데이터를 모두 전송 후 종료
- 4-way handshake 수행
- TIME_WAIT 발생
- 상대방이 데이터를 안전하게 받음

RST:
- 버퍼 데이터를 버리고 즉시 종료
- TIME_WAIT 없음
- 상대방이 데이터를 못 받을 수 있음

RST 발생 상황:
1. 존재하지 않는 포트 접속
2. SO_LINGER(0) 옵션 사용
3. Half-Open 연결 감지
4. 버퍼에 데이터 남은 상태에서 close()"
```

---

### 📌 시나리오 5: TCP 헤더

**Q5. TCP 헤더의 주요 필드를 설명해주세요.**

```
"TCP 헤더의 주요 필드는:

1. 포트 번호 (각 16비트)
   - 출발지/목적지 애플리케이션 식별

2. 시퀀스 번호 (32비트)
   - 전송하는 데이터의 바이트 위치
   - 패킷 번호가 아닙니다!

3. ACK 번호 (32비트)
   - 다음에 받고 싶은 바이트 번호
   - 누적 확인응답

4. 플래그 (6비트)
   - SYN, ACK, FIN, RST, PSH, URG

5. 윈도우 크기 (16비트)
   - 수신 가능한 데이터 크기
   - 흐름 제어에 사용

6. 체크섬 (16비트)
   - 헤더+데이터+의사헤더 검증"
```

**→ 꼬리 Q5-1. 시퀀스 번호를 자세히 설명해주세요.**

```
"시퀀스 번호는 전송하는 데이터의 바이트 위치입니다.
패킷의 순서가 아니라 바이트 단위로 증가합니다.

예를 들어:
- SEQ=1000에서 500바이트 전송
- 다음 SEQ=1500 (1001이 아님!)

SYN이나 FIN도 1바이트를 소비합니다:
- SYN: SEQ=100
- SYN+ACK: ACK=101 (SYN 소비)

이렇게 하면:
1. 순서를 정확히 보장할 수 있고
2. 중복 패킷을 감지할 수 있으며
3. 재조립이 쉬워집니다"
```

**→ 꼬리 Q5-2. ACK 번호는 무엇을 의미하나요?**

```
"ACK 번호는 '다음에 받고 싶은 바이트 번호'입니다.
누적 확인응답 방식입니다.

예시:
- 1000, 2000, 3000번 패킷 전송
- 1000, 2000 수신 성공, 3000 손실
- 수신자는 계속 ACK=3000 전송
  (3000번부터 보내달라)

3 duplicate ACK (같은 ACK 3번):
- 송신자가 패킷 손실 감지
- Fast Retransmit으로 즉시 재전송
- 타임아웃 기다리지 않음

이것이 TCP의 신뢰성 보장 메커니즘입니다."
```

**→ 꼬리 Q5-3. 윈도우 크기가 0이면 어떻게 되나요?**

```
"Zero Window 상태가 됩니다.
수신자의 버퍼가 가득 차서
더 이상 받을 수 없다는 의미입니다.

동작 과정:
1. 수신자: rwnd=0 전송
2. 송신자: 전송 멈춤
3. 송신자: Window Probe (1바이트) 주기적 전송
4. 수신자: 버퍼 비우면 윈도우 업데이트
5. 송신자: 전송 재개

Window Probe:
- 1바이트씩 전송
- 지수 백오프 (1초, 2초, 4초...)
- 최대 60초 간격

이것이 TCP의 흐름 제어입니다."
```

---

### 📌 시나리오 6: 흐름 제어 vs 혼잡 제어

**Q6. 흐름 제어와 혼잡 제어의 차이를 설명해주세요.**

```
"흐름 제어와 혼잡 제어는 목적과 주체가 다릅니다.

흐름 제어 (Flow Control):
- 목적: 수신자 보호 (버퍼 오버플로우 방지)
- 주체: 수신자가 윈도우 크기(rwnd) 알림
- 방법: 슬라이딩 윈도우
- 대상: 특정 연결

혼잡 제어 (Congestion Control):
- 목적: 네트워크 보호 (혼잡 방지)
- 주체: 송신자가 혼잡 윈도우(cwnd) 계산
- 방법: Slow Start, Congestion Avoidance 등
- 대상: 전체 네트워크

실제 전송량 = min(rwnd, cwnd)
둘 중 작은 값을 사용합니다."
```

**→ 꼬리 Q6-1. 슬라이딩 윈도우를 설명해주세요.**

```
"슬라이딩 윈도우는 흐름 제어 메커니즘입니다.

동작 원리:
1. 송신자는 ACK 없이도 윈도우 크기만큼 전송 가능
2. ACK를 받으면 윈도우가 앞으로 슬라이드
3. 수신자는 버퍼 상태에 따라 윈도우 크기 조절

예시:
- 윈도우 크기: 8바이트
- 1~8번 전송 가능
- 1~4번 전송 후 ACK 대기
- 4번까지 ACK 받음
- 윈도우가 5~12번으로 슬라이드

장점:
- 파이프라인 방식으로 효율적
- 수신자 버퍼를 고려한 전송
- ACK 대기 시간 감소"
```

**→ 꼬리 Q6-2. 혼잡 제어는 어떻게 동작하나요?**

```
"혼잡 제어는 4단계 알고리즘으로 동작합니다:

① Slow Start:
- cwnd를 1 MSS부터 시작
- ACK 받을 때마다 2배 증가 (지수 증가)
- 1 → 2 → 4 → 8 → 16...
- ssthresh 도달까지

② Congestion Avoidance:
- ssthresh 도달 후 선형 증가
- RTT마다 cwnd +1
- 16 → 17 → 18 → 19...
- AIMD (Additive Increase Multiplicative Decrease)

③ Fast Retransmit:
- 3 duplicate ACK 수신 시
- 타임아웃 기다리지 않고 즉시 재전송

④ Fast Recovery:
- ssthresh = cwnd / 2
- cwnd = ssthresh
- Congestion Avoidance로 복귀

패킷 손실을 혼잡 신호로 감지합니다."
```

**→ 꼬리 Q6-3. Slow Start가 왜 ’Slow’인가요?**

```
"지수 증가인데 왜 느린가 헷갈릴 수 있는데,
역사적 맥락을 이해해야 합니다.

초기 TCP:
- 윈도우 크기 제한 없이 대량 전송
- 네트워크 혼잡 유발
- 패킷 손실 폭증

Slow Start 도입:
- 1부터 조심스럽게 시작
- 네트워크 상태를 파악하며 증가
- 초기 방식에 '상대적으로' 느림

실제로는 지수 증가라 빠르지만,
무제한 전송보다는 '느리게' 시작한다는 의미입니다."
```

**→ 꼬리 Q6-4. AIMD가 무엇이고 왜 사용하나요?**

```
"AIMD는 Additive Increase Multiplicative Decrease입니다.

동작:
- Additive Increase: 선형 증가 (+1)
- Multiplicative Decrease: 지수 감소 (×0.5)

예시:
- 정상: 16 → 17 → 18 → 19...
- 패킷 손실: 20 → 10 (절반)
- 다시 증가: 10 → 11 → 12...

왜 사용?
1. 네트워크 공정성
   - 여러 연결이 대역폭을 공정하게 분배

2. 안정성
   - 급격한 증가 방지
   - 빠른 감소로 혼잡 신속 해소

3. 수렴성
   - 결국 최적 전송량으로 수렴

이것이 TCP의 혼잡 제어 핵심 알고리즘입니다."
```

---

### 📌 시나리오 7: 실무 시나리오

**Q7. www.google.com을 브라우저에 입력하면 어떤 일이 일어나나요?**

```
"전체 과정을 OSI 계층별로 설명하겠습니다:

1. DNS 조회 (L7, UDP)
   - 브라우저/OS 캐시 확인
   - DNS 서버에 A 레코드 요청
   - IP 주소 획득 (예: 172.217.175.46)

2. TCP 3-way handshake (L4)
   - SYN → SYN+ACK → ACK
   - 443번 포트로 연결

3. TLS handshake (L6)
   - Client Hello
   - Server Hello + 인증서
   - 키 교환
   - 암호화 통신 시작

4. HTTP 요청 (L7)
   - GET / HTTP/1.1
   - Host: www.google.com

5. HTTP 응답
   - 200 OK
   - HTML, CSS, JS 수신

6. 브라우저 렌더링
   - DOM 트리 생성
   - CSSOM 생성
   - 렌더 트리 → 레이아웃 → 페인팅

7. 추가 리소스 로드
   - 이미지, 폰트 등
   - 병렬 연결 (HTTP/1.1: 6개, HTTP/2: 1개 멀티플렉싱)

8. 연결 종료
   - Keep-Alive면 유지
   - 아니면 4-way handshake"
```

**→ 꼬리 Q7-1. DNS 조회를 더 자세히 설명해주세요.**

```
"DNS 조회는 계층적으로 진행됩니다:

1. 로컬 캐시
   - 브라우저 캐시 (TTL 기반)
   - OS 캐시 (/etc/hosts, DNS 캐시)

2. 재귀적 쿼리 (Recursive Query)
   - Local DNS 서버 (ISP 제공)
   - 전체 조회를 대신 수행

3. 반복적 쿼리 (Iterative Query)
   - Root DNS (.): "com은 여기로 가"
   - TLD DNS (.com): "google.com은 여기로 가"
   - Authoritative DNS: "www는 172.217.175.46"

4. 응답
   - A 레코드 (IPv4 주소)
   - AAAA 레코드 (IPv6 주소)
   - CNAME (별칭)
   - TTL과 함께 캐싱

UDP 사용 이유:
- 빠른 조회 (512바이트 이하)
- 실패하면 재시도 간단
- 512바이트 초과하거나 Zone Transfer는 TCP"
```

**→ 꼬리 Q7-2. HTTPS는 어떻게 암호화되나요?**

```
"HTTPS는 TLS(Transport Layer Security)를 사용합니다.

TLS Handshake 과정:

1. Client Hello
   - 지원하는 암호화 스위트 목록
   - TLS 버전
   - 랜덤 데이터

2. Server Hello
   - 선택한 암호화 스위트
   - 서버 인증서 (공개키 포함)
   - 랜덤 데이터

3. 인증서 검증
   - CA(Certificate Authority) 서명 확인
   - 도메인 일치 확인
   - 유효기간 확인

4. 키 교환 (ECDHE)
   - 클라이언트가 Pre-Master Secret 생성
   - 서버 공개키로 암호화하여 전송
   - 양쪽이 Master Secret 계산

5. Session Key 생성
   - 양쪽 랜덤 데이터 + Master Secret
   - 대칭키 생성 (AES-128/256)

6. Finished 메시지
   - 암호화된 핸드셰이크 검증
   - 이후 모든 데이터는 대칭키로 암호화

TLS 1.3:
- 1-RTT 또는 0-RTT (재연결)
- 더 강력한 암호화
- 취약한 알고리즘 제거"
```

```
"HTTP Keep-Alive는 TCP 연결을 재사용하는 기능입니다.

HTTP/1.0:
- 요청/응답마다 연결 생성/종료
- 오버헤드 큼 (3-way + 4-way)

HTTP/1.1:
- 기본적으로 Keep-Alive 활성화
- Connection: keep-alive 헤더
- 한 연결에서 여러 요청/응답

동작:
1. TCP 연결 수립
2. 요청1 → 응답1
3. 요청2 → 응답2
4. 요청3 → 응답3
5. Idle 타임아웃(보통 5~10초) 후 종료

장점:
- 3-way handshake 오버헤드 제거
- TLS handshake 재사용
- 응답 속도 향상
- TIME_WAIT 소켓 감소

설정:
- Keep-Alive timeout: 5~10초
- Max requests: 100~1000개

주의:
- 서버 리소스 사용 (연결 유지)
- 로드밸런서 세션 유지 필요"
```
