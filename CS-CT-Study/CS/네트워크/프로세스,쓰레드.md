## 운영체제란?

운영체제(OS, Operating System)는 실행할 프로그램에 필요한 자원을 할당하고,  
프로그램이 올바르게 실행되도록 **프로세스 관리, 스케줄링, 메모리 관리, 입출력 관리** 등을 담당하는 특별한 프로그램이다.

운영체제 또한 하나의 프로그램이므로 메모리에 적재되어야 하며,  
컴퓨터가 부팅될 때 **커널 영역**에 적재되어 실행된다.  
일반 사용자 프로그램은 **유저 영역**, 운영체제 커널은 **커널 영역**에 위치하며,  
커널은 하드웨어에 대한 직접 접근 권한을 가진다.

---

## 프로세스란?

**프로세스(Process)**란 메모리에 적재되어 실행 중인 프로그램을 의미한다.  
CPU는 한 순간에는 하나의 프로세스(또는 하나의 스레드)만 실행할 수 있기 때문에,  
운영체제는 여러 프로세스를 빠르게 번갈아가며 실행해서 **동시에 실행되는 것처럼 보이게** 만든다.

- 하나의 프로세스는 **최소 한 개 이상의 스레드**를 가진다.
- 일반적으로 “단일 스레드 프로세스”도 존재하지만, 많은 애플리케이션은 멀티 스레드를 사용한다.

---

## 프로세스의 메모리 구조

일반적인 프로세스의 메모리 공간은 크게 다음 네 영역으로 나뉜다.

1. **코드 영역 (Text Segment)**  
   - 실행 가능한 기계어 코드(명령어)가 저장되는 영역  
   - 함수, 제어문 등이 컴파일된 결과  
   - 보통 **읽기 전용(Write-Protect)**으로 설정되어 코드가 임의로 수정되지 않도록 한다.

2. **데이터 영역 (Data Segment)**  
   - 전역 변수, static 변수 등이 저장되는 영역  
   - 프로그램 시작 시 할당되어 **프로그램이 종료될 때까지** 유지된다.  
   - 초기값이 있는 전역/정적 변수: `.data`,  
     초기값이 없는 전역/정적 변수: `.bss`에 배치되는 식으로 나뉘기도 한다.

3. **힙 영역 (Heap)**  
   - 실행 도중 **동적 할당**되는 메모리 영역  
   - C의 `malloc/free`, Java의 `new` 같은 것이 사용하는 공간  
   - 필요할 때 할당하고, 더 이상 필요 없을 때 해제해야 한다.  
     (언어에 따라 가비지 컬렉터가 대신 정리해주기도 함)

4. **스택 영역 (Stack)**  
   - 함수 호출 시 사용되는 **매개변수, 지역 변수, 리턴 주소** 등이 저장되는 영역  
   - 함수 호출 시 쌓이고, 함수가 끝나면 자동으로 정리된다.  
   - **각 스레드마다 독립된 스택을 갖는다**는 점이 중요하다.

---

## 프로세스 제어 블록(PCB: Process Control Block)

모든 프로세스는 CPU를 사용해야 실행될 수 있지만, CPU 자원은 한정되어 있다.  
여러 프로세스를 번갈아 실행하기 위해, 운영체제는 각 프로세스의 상태를 **PCB**라는 구조체에 저장해 관리한다.  
PCB는 커널 영역에 존재하며, **문맥 교환(context switch)** 시에 활용된다.

PCB에는 대표적으로 다음과 같은 정보가 담긴다.

- **프로세스 ID(PID)**: 프로세스를 식별하기 위한 고유 번호
- **레지스터 값들**:  
  - 프로그램 카운터(PC, 다음에 실행할 명령의 주소)  
  - 스택 포인터(SP)  
  - 일반 목적 레지스터 값
- **프로세스 상태**: 생성, 준비, 실행, 대기, 종료 등
- **CPU 스케줄링 정보**: 우선순위, 사용 시간 등
- **메모리 관리 정보**: 페이지 테이블/세그먼트 정보 등
- **열린 파일, 입출력 정보 등**

---

## 문맥 교환(Context Switch)

CPU는 한 번에 한 프로세스(정확히는 한 스레드)만 실행할 수 있다.  
여러 프로세스를 “동시에” 사용하는 것처럼 보이게 하기 위해  
운영체제는 **현재 실행 중인 프로세스의 문맥(context)을 저장하고, 다른 프로세스의 문맥을 복원**하는 작업을 반복한다.  
이 과정을 **문맥 교환(context switch)** 라고 한다.

### 문맥 교환 과정

1. **인터럽트 또는 시스템 호출 발생**  
   - 타이머 인터럽트(시간 할당량 소진)  
   - I/O 요청, 시스템 콜 등으로 인해 CPU를 양보해야 하는 상황 발생

2. **현재 프로세스 상태 저장**  
   - 현재 프로세스의 레지스터 값(PC, SP 포함)과 상태 정보를 PCB에 저장한다.

3. **다음 프로세스 상태 복원**  
   - 스케줄러가 다음에 실행할 프로세스를 선택하고,  
     그 프로세스의 PCB에서 레지스터 값과 상태를 꺼내와 복원한다.

4. **새 프로세스 실행**  
   - 복원된 상태로부터 명령을 이어서 실행한다.

프로세스 간 문맥 교환은 **PCB 교체 + 주소 공간 전환(페이지 테이블, TLB flush 등)**까지 필요하므로  
비용이 큰 편이다. 반면, 같은 프로세스 내 스레드 전환은 주소 공간이 같기 때문에 비교적 가볍다.

---

## 프로세스 상태

프로세스는 실행되는 동안 여러 상태를 오가며, 이 상태 정보 역시 PCB로 관리된다.  
대표적인 상태는 다음과 같다.

1. **생성 상태(New)**  
   - 프로세스가 생성되고, PCB가 할당된 상태  
   - 메모리 적재와 초기 설정이 완료되면 준비 상태로 이동한다.

2. **준비 상태(Ready)**  
   - **CPU 할당만 기다리는 상태**  
   - 실행할 준비는 되었지만, 아직 CPU를 배정받지 못한 상태이다.

3. **실행 상태(Running)**  
   - CPU를 실제로 할당받아 명령을 수행 중인 상태  
   - 타이머 인터럽트로 할당 시간이 끝나면 다시 준비 상태로 가고,  
     I/O 요청 등으로 중단되면 대기 상태로 이동한다.

4. **대기 상태(Waiting / Blocked)**  
   - I/O 완료, 이벤트 발생 등 **어떤 조건을 기다리는 상태**  
   - 대기하던 작업이 끝나면 다시 준비 상태로 이동한다.

5. **종료 상태(Terminated)**  
   - 프로세스 실행이 완전히 끝난 상태  
   - PCB와 사용하던 메모리/자원을 정리한다.

---

## 스레드(Thread)

스레드는 **CPU가 실제로 실행하는 최소 단위**로,  
하나의 프로세스 안에서 여러 실행 흐름을 만들기 위한 개념이다.

- 하나의 프로세스는 **최소 1개 이상의 스레드**를 가진다.
- 같은 프로세스 내의 스레드들은
  - 코드, 데이터, 힙 영역을 **공유**하고
  - 각자 **독립된 스택과 레지스터(PC, SP 등)**를 가진다.

운영체제는 각 스레드에 대해서도 **스레드 제어 블록(TCB, Thread Control Block)**을 통해  
스레드 ID, 상태, 레지스터 값 등을 관리한다.

---

## 멀티 프로세스와 멀티 스레드

### 멀티 프로세스(Multi-process)

여러 개의 프로세스를 동시에 실행하는 방식이다.

- **장점**
  - 프로세스 간 메모리가 완전히 분리되어 있어 **안정성**이 높다.
  - 하나의 프로세스에 문제가 생겨도 다른 프로세스에 직접적인 영향을 주지 않는다.
  - 예: 브라우저(Chrome)에서 각 탭을 별도 프로세스로 두는 구조

- **단점**
  - 각 프로세스가 독립된 메모리 공간을 사용하므로  
    프로세스 간 데이터 공유를 위해 **IPC(파이프, 소켓, 공유메모리 등)**가 필요하다.
  - 프로세스 간 문맥 교환은 주소 공간까지 바꿔야 하기 때문에  
    상대적으로 **오버헤드가 크다**.

### 멀티 스레드(Multi-thread)

하나의 프로세스 안에서 여러 스레드를 사용해 동시에 실행하는 방식이다.

- **장점**
  - 코드/데이터/힙을 공유하므로 스레드 간 **데이터 전달이 빠르다**.
  - 같은 주소 공간을 사용하기 때문에 문맥 교환 비용이  
    멀티 프로세스보다 **작다**.
  - 메모리를 더 효율적으로 사용할 수 있다.

- **단점**
  - 자원을 공유하기 때문에 **동기화 문제가 필연적으로 발생**할 수 있다.
    - 레이스 컨디션, 데드락, 기아(starvation) 등
  - 하나의 스레드가 메모리를 잘못 다루면  
    프로세스 전체가 비정상 종료될 수 있다.

---

---

## 기술적인 고민과의 연결

### 1. IPC는 언제 쓰는가?

IPC(Inter-Process Communication)는 말 그대로  
**“서로 다른 프로세스끼리 데이터를 주고받을 때”** 사용하는 모든 통신 방법을 말한다.

실제로 IPC가 필요한 순간은 대략 이렇게 나뉜다.

1. **프로세스를 분리했을 때**
   - 웹 서버, 배치, MQ 브로커, DB, Redis 같은 것들을  
     각각 별도 프로세스/컨테이너로 띄우는 순간,  
     이들 사이의 호출은 전부 IPC가 된다.
   - 예) Spring 애플리케이션 ↔ DB, Redis, 외부 HTTP API, RabbitMQ 브로커 등

2. **언어/프레임워크가 다른 서비스끼리 통신할 때**
   - Java(Spring) ↔ Node.js 서버 ↔ Python 배치 처럼  
     같은 코드 베이스 안에서 함수 호출로 공유할 수 없는 경우  
     → 무조건 IPC(HTTP, gRPC, MQ, Redis 등)를 쓴다.

3. **모듈 간 결합도를 낮추고 싶을 때**
   - “요청 후 바로 응답” 구조에서 벗어나  
     비동기 처리, 버퍼링, 재시도, 백프레셔 같은 걸 하고 싶으면  
     → HTTP 호출 대신 메시지 큐나 Redis 같은 IPC 수단을 사용하게 된다.

요약하면,  
**“프로세스를 나누는 순간부터, 그 사이를 어떻게 연결할지 고민하는 게 IPC 설계”**다.

---

### 2. IPC 수단 비교 – HTTP/TCP vs 메시지 큐 vs Redis vs 공유 DB

운영체제 교과서에서는 파이프, 메시지 큐, 공유 메모리 같은 primitive를 얘기하지만,  
우리가 실제로 쓰는 건 거의 아래 네 가지 패턴으로 귀결된다.

#### 2-1. HTTP / gRPC / TCP 직접 호출

- **특징**
  - 요청-응답 구조, 동기 통신
  - 바로 결과를 받아야 할 때 사용
- **장점**
  - 이해하기 쉽고, 구현이 간단하다.
  - API 스펙(REST/gRPC)만 맞추면 언어/플랫폼 상관없이 연동 가능.
- **단점**
  - 상대 서비스가 느리거나 죽으면 바로 내 요청도 막힌다.
  - 리트라이, 타임아웃, 백프레셔, 서킷 브레이커를 따로 설계해야 한다.

#### 2-2. 메시지 큐 (RabbitMQ, Kafka 등)

- **특징**
  - **브로커 프로세스**가 중간에 서서 메시지를 큐에 적재하고 전달
  - 생산자(Producer)와 소비자(Consumer)를 완전히 분리
- **장점**
  - 비동기 처리, 버퍼링 → 피크 트래픽 흡수 가능
  - 재시도, DLQ(사망 큐), 라우팅, 브로드캐스트 등 고급 기능
  - 장애 격리가 잘 된다. 소비자가 잠깐 죽어도 메시지는 큐에 남아 있음.
- **단점**
  - 시스템이 복잡해진다. 브로커 운영/모니터링 필요.
  - API도 HTTP보다 복잡하고, 운영 지식도 요구된다.

#### 2-3. Redis (캐시 + 공유 저장소 + “사실상” 메시지 큐)

Redis는 딱 한 역할이 아니라, 패턴에 따라 성격이 달라진다.

1. **공유 메모리/캐시**
   - 여러 프로세스가 같은 Redis 키를 보는 **공유 데이터 저장소** 역할
   - 예: 토큰/세션, 카운터, 임시 데이터, 분산락 등
   - 장점: 메모리 기반이라 매우 빠르고, 구현이 단순
   - 단점: 기본적으로 인메모리 특성상 영속성이 상대적으로 약하다(옵션에 따라 다르지만).

2. **메시지 큐처럼 사용 (리스트/스트림)**
   - `LPUSH` / `BRPOP`, Redis Streams 등을 이용하면  
     하나의 Queue처럼 사용할 수 있다.
   - 장점: 간단한 큐나 작업 분배는 충분히 처리 가능
   - 단점: RabbitMQ/Kafka 수준의 라우팅, 퍼시스턴스, 리트라이, 소비자 그룹 등은  
     직접 구현해야 하는 부분이 많다.

3. **Pub/Sub**
   - 발행/구독 방식으로, 구독 중인 클라이언트들에게만 메시지를 방송
   - **중요 포인트**:  
     - 메시지가 **브로커에 남아 있지 않고, 그 순간 듣고 있는 애들만** 받는다.
   - 장점: 실시간 알림, 방송용에 좋다.
   - 단점: MQ처럼 “나중에 다시 읽기, 처리 실패 후 재시도” 같은 건 기본적으로 안 된다.

→ 결론:  
**Redis도 “메시지 큐 역할”을 할 수는 있지만**,  
- **확실한 내구성, 복잡한 라우팅, 소비자 그룹, 재시도 전략**이 필요하면 RabbitMQ/Kafka 같은 전용 MQ가 더 적합하고,  
- “간단한 작업 큐, 공유 상태, 락, 카운터” 정도면 Redis로도 충분히 커버 가능하다.

#### 2-4. 공유 DB 테이블

- **특징**
  - 여러 프로세스가 **같은 DB 테이블**을 참조/갱신하면서 협력
  - 예: Job 테이블, Status 테이블, Outbox 패턴 등
- **장점**
  - 트랜잭션, 일관성, 쿼리 등 기존 DB 기능을 그대로 활용 가능
  - 별도 MQ 인프라 없이도 간단한 비동기/워크플로우 구현 가능
- **단점**
  - 읽기/쓰기가 많아지면 DB가 병목/공유 자원이 된다.
  - MQ처럼 consumer 레벨의 back-pressure, 리트라이 정책을 세밀하게 다루기 어렵다.

---

### 3. Vert.x / Node.js / Redis – 싱글 스레드 + IPC 조합

이번 주에 계속 고민했던 포인트가 이거였다:

> “Vert.x, Node.js, Redis는 싱글 스레드 기반인데 왜 빠른가?”

- 공통점:  
  **싱글(혹은 소수) 스레드 + 이벤트 루프 + 논블로킹 I/O** 모델
- 장점:
  - 스레드 수가 적으니 컨텍스트 스위칭 비용이 줄어든다.
  - 공유메모리 동기화(락) 고민을 구조적으로 줄인다.
- 대신:
  - CPU 많이 쓰는 작업은 **워커 스레드나 별도 서비스(다른 프로세스)**로 떼어내야 한다.
  - “이벤트 루프에 블로킹 작업을 올리지 않는 설계”가 핵심 고민 포인트가 된다.

---

### 4. 멀티 스레드 환경에서 동기화는 언제/어떻게 쓰는가?

멀티 스레드(Spring, Tomcat, HikariCP 등)에서는  
**“같은 프로세스 안에서의 동시성 문제”**를 먼저 잡아야 한다.

1. **언제 동기화가 필요한가?**
   - 여러 스레드가 **같은 데이터를 쓰는(write)** 상황에서만 진짜로 필요하다.
   - 예:
     - 전역 `Map`, `List`, 캐시 객체를 수정할 때
     - 통계 카운터/시퀀스를 증가시킬 때
     - 상태를 가진 싱글톤 서비스 빈이 필드를 변경할 때

2. **어떻게 막을 것인가? (패턴)**

   - **애초에 공유 상태를 없애기**
     - 서비스/도메인 객체를 최대한 **stateless**하게 만들기
     - 변경 가능한 필드는 가능한 한 지역 변수나 메서드 내부로 숨기기

   - **스레드 세이프 도구 사용**
     - 컬렉션: `ConcurrentHashMap`, `ConcurrentLinkedQueue`, `CopyOnWriteArrayList` 등
     - 숫자/플래그: `AtomicInteger`, `AtomicLong`, `AtomicBoolean`
     - 락: `synchronized`, `ReentrantLock`, 필요 시 `ReadWriteLock`

   - **락 범위를 최소화**
     - 꼭 필요한 코드만 감싸고, 락 안에서 DB/외부 HTTP 호출 같은 느린 작업은 피하기  
     → 그렇지 않으면 데드락, Convoy effect(호위 효과)의 원인이 된다.

→ 정리하면,  
- 프로세스 간에는 **IPC 선택(HTTP, MQ, Redis, DB 등)**이 중요하고,  
- 프로세스 내부에서는 **동시성 제어(락, Atomic, Concurrent 컬렉션)**가 중요하다.  
둘 다 결국 **“운영체제가 프로세스/스레드/메모리를 어떻게 다루는지”**에서 출발하는 고민이다.

