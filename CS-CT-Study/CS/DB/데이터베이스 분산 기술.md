# 🗄️ 대용량 데이터 처리: DB 분산 기술 완벽 정리

---

## 📌 1. RDBMS vs NoSQL: 철학의 차이

### RDBMS의 핵심: ACID (강한 일관성)
```
특징:
✓ 원자성(Atomicity): 트랜잭션 전부 또는 무
✓ 일관성(Consistency): 무결성 제약 항상 유지
✓ 격리성(Isolation): 동시 트랜잭션 독립
✓ 지속성(Durability): 커밋 후 영구 보존

비용:
✗ 수평 확장 어려움 (샤딩 시 크로스샤드 트랜잭션 복잡)
✗ 느린 쓰기 (동기화 대기)
```

### NoSQL의 핵심: BASE (높은 가용성)
```
특징:
✓ Basically Available: 기본적으로 항상 접근 가능
✓ Soft state: 상태는 일시적
✓ Eventually consistent: 결국 일관성 도달

이점:
✓ 수평 확장 무한 (각 노드 독립적)
✓ 높은 처리량 (대량 쓰기)
✓ 유연한 스키마

비용:
✗ 약한 일관성 (수 밀리초~초 지연)
✗ 복잡한 조인 불가능
```

### 선택 기준 (의사결정 테이블)

| 상황 | RDBMS | NoSQL |
|------|-------|-------|
| 데이터 관계 복잡 | ✓ JOIN, FK | - |
| 트랜잭션 중요 | ✓ 송금, 주문 | - |
| 강한 일관성 필수 | ✓ | - |
| 대용량 데이터 (TB~PB) | - | ✓ |
| 높은 쓰기 처리량 | - | ✓ |
| 유연한 스키마 | - | ✓ |

---

## 🔄 2. Replication (복제): 일관성 vs 속도

### 동기 복제 (Synchronous)
```
Master ←→ Replica1, Replica2
모두 ACK 받을 때까지 대기

장점: ✓ 강한 일관성 (모든 노드 동일)
단점: ✗ 느린 쓰기 (가장 느린 서버 속도로)
      ✗ 한 Replica 장애 → 전체 정지
```

### 비동기 복제 (Asynchronous)
```
Master → 즉시 응답
  ↓ (백그라운드)
Replica1, Replica2

장점: ✓ 빠른 쓰기 (Master만 대기)
      ✓ Replica 장애 무시
단점: ✗ 약한 일관성 (지연 중 장애 → 데이터 손실)
```

### 실무 선택: 비동기 + Read-After-Write 일관성
```java
// 쓴 직후 읽을 때는 Master에서
if (userJustModified) {
    user = masterDB.findById(id);
} else {
    user = replicaDB.findById(id);  // 읽기 분산
}
```

---

## 📍 3. Partitioning vs Sharding: 분할의 스케일

### Partitioning (단일 DB 내 분할)
```
같은 MySQL 인스턴스 내
├── Partition1: ID 1-10000
├── Partition2: ID 10001-20000
└── Partition3: ID 20001-30000

효과: Partition Pruning으로 스캔 범위 축소
장점: ✓ 쿼리 성능 향상
      ✓ 트랜잭션 원자성 유지
      ✓ 관리 간단
단점: ✗ 확장의 한계 (한 서버 용량)
```

### Sharding (여러 DB 서버 간 분산)
```
Application
    ├→ Shard1: Server_A (userId % 3 == 0)
    ├→ Shard2: Server_B (userId % 3 == 1)
    └→ Shard3: Server_C (userId % 3 == 2)

각 샤드는 독립된 DB 서버

효과: 무제한 수평 확장
장점: ✓ 거의 무한 확장 가능
      ✓ 각 서버 부하 분산
단점: ✗ 크로스샤드 연산 복잡
      ✗ 트랜잭션 어려움
      ✗ 운영 복잡도 높음
```

### Shard Key 선택 (가장 중요!)
```
좋은 Shard Key 특성:
1. 균등 분포: 데이터가 모든 샤드에 골고루
   (예: userId % N → OK / 지역별 → Hotspot 위험)
   
2. 불변성: 한번 정해지면 안 바뀜
   (예: userId ✓ / 지역 ✗)
   
3. 쿼리 패턴: 대부분 쿼리가 Shard Key 포함
   (예: WHERE userId = X → OK)

나쁜 예: firstName으로 샤딩
├── Shard_A: "김" → 3천만 명 (과부하)
├── Shard_B: "이" → 3천만 명 (과부하)
└── Shard_C: 나머지 → 4천만 명 (가벼움)
→ 핫스팟 발생!
```

### 크로스샤드 연산 (근본 문제)
```
문제: SELECT * FROM friends WHERE userId IN (1,2,3,4,5)
      → 친구들이 여러 샤드에 분산
      → 각 샤드에 별도 쿼리 필요 (N번)
      → 네트워크 왕복 증가, 응답시간 증가

해결책:
① Denormalization: 데이터 중복으로 같은 샤드에
   (장점: 빠름 | 단점: 중복, 일관성 문제)
   
② Aggregation at App Layer: 여러 샤드 조회 후 앱에서 merge
   (장점: 유연함 | 단점: 느림, 네트워크 비용)
```

---

## 🗂️ 4. ORM (Object-Relational Mapping): 편의성의 대가

### ORM의 근본 목표
```
객체 세계          DB 세계
─────────         ────────
User.addPost()  → INSERT INTO posts
user.getName()  → SELECT name FROM users
                
⇒ 이 매핑을 자동화하는 것이 ORM
```

### ORM의 생명주기: Persistent Context

```
1. Detached        2. Managed              3. Flush           4. Detached
   메모리만            DB 추적 시작            변경사항 쓰기        추적 중단
      ↓                   ↓                     ↓                  ↓
   new User()  →  persist() / save()  →  commit()  →  close()
                   
                   Dirty Check 동작
                   (변경 자동 감지)
```

### ORM의 성능 문제 1: N+1

```java
// 유저 100명 조회
List<User> users = userRepository.findAll();  // 1번 쿼리
users.forEach(user -> {
    user.getPosts();  // LAZY LOADING
    // 각각 새로운 쿼리 → 100번
});
// 총 101번 쿼리!
```

**원인: Lazy Loading (지연 로딩)**
```
@OneToMany(fetch = FetchType.LAZY)  // 기본값!
private List<Post> posts;

→ posts는 처음엔 로드 안 됨 (Proxy 객체)
→ user.getPosts() 호출 시점에 쿼리 발생
```

**해결책 (3가지)**

| 방법 | 코드 | 장점 | 단점 |
|------|------|------|------|
| Eager | `fetch = FetchType.EAGER` | 간단함 | 불필요한 데이터도 항상 로드 |
| Fetch Join | `JOIN FETCH u.posts` | 필요한 것만 로드 | JPQL 복잡 |
| 쿼리 분리 | 유저 조회 후 배치로 포스트 조회 | 최적화 가능 | 애플리케이션 로직 필요 |

### ORM의 성능 문제 2: 생성된 SQL의 비효율성

```java
// ORM이 모든 컬럼 조회
@Entity
public class User {
    private Long id;
    private String name;
    private String email;
    private String phone;
    private String address;
    // ... 20개 컬럼
}
List<User> users = userRepository.findAll();
// SELECT u.id, u.name, u.email, ... (20개) FROM users u;

// 하지만 목록 페이지는 id, name만 필요!
```

**해결책: DTO 프로젝션**
```java
public interface UserNameDTO {
    Long getId();
    String getName();
}

@Query("SELECT u.id, u.name FROM User u")
List<UserNameDTO> findAllProjection();
// SELECT u.id, u.name FROM users u;  (필요한 것만!)
```

---

## 🔌 5. JDBC: ORM의 기저, 성능의 무기

### JDBC의 역할: DB 표준 인터페이스

```
Application Layer
       ↓
ORM Layer (Hibernate, JPA)
       ↓
JDBC Layer ← ORM도 결국 JDBC 위에서 동작
       ↓
JDBC Driver (MySQL Driver, PostgreSQL Driver, ...)
       ↓
Database
```

### JDBC를 사용해야 할 때

```
1. ORM으로 표현 불가능한 복잡한 SQL
   - PIVOT, 재귀 쿼리, DB 특화 함수

2. 극도의 성능 최적화 필수
   - 응답시간이 수십 MS 이하로 요구
   - ORM 오버헤드가 허락 불가

3. 대용량 배치 처리
   - 수백만 건 데이터 이동
   - ORM의 변경 추적(Dirty Check) 오버헤드 피해야 함
```

### JDBC의 성능 우위: Batch Processing

```java
// ORM (100만 건)
for (int i = 0; i < 1000000; i++) {
    userRepository.save(new User("name" + i));
    // 변경 감지 + SQL 생성 + 파싱 + 실행 반복
}
// 수십 초

// JDBC Batch (100만 건)
PreparedStatement ps = conn.prepareStatement(sql);
for (int i = 0; i < 1000000; i++) {
    ps.setString(1, "name" + i);
    ps.addBatch();
    if (i % 5000 == 0) ps.executeBatch();  // 5000개씩 한 번에
}
// 수 초 (10배 빠름!)
```

**이유:**
```
ORM (1000건): 쿼리 생성 × 1000 + 파싱 × 1000 + 실행 × 1000
JDBC (1000건, 배치 100): 쿼리 생성 × 1 + 파싱 × 10 + 실행 × 10
→ 거의 100배 차이!
```

---

## 🎯 6. 최종 의사결정 프레임워크

### 데이터 특성별 기술 선택

```
시작: 데이터 저장 요구사항
            ↓
    ┌───────────────────┐
    │ 강한 일관성 필수? │
    └───────────────────┘
          YES ↙        ↘ NO
          ↓            ↓
       RDBMS         NoSQL
          ↓            ↓
    ┌─────────────┐  ┌────────────┐
    │데이터 확장? │  │높은 쓰기?  │
    └─────────────┘  └────────────┘
    YES ↙ ↘ NO      높음 ↙ ↘ 낮음
     ↓      ↓         ↓      ↓
   샤딩   파티션  Cassandra MongoDB
     ↓
  ┌──────────────────┐
  │복잡한 트랜잭션?  │
  └──────────────────┘
  YES ↙ ↘ NO
   ↓      ↓
심신중  Hash샤딩
```

### 쿼리 최적화 체크리스트

```
□ RDBMS 선택했나?
   └─ □ 자주 조회되는 컬럼만 쿼리하는가?
   └─ □ N+1 문제는 없는가? (Fetch Join / DTO Projection)
   └─ □ 인덱스를 적절히 설정했는가?

□ 복잡한 쿼리 있는가?
   └─ JDBC 네이티브 쿼리 고려

□ 대용량 배치 작업 있는가?
   └─ JDBC Batch Processing 사용

□ 높은 처리량 필요한가?
   └─ NoSQL 또는 Replication + Read Scaling 고려

□ 수평 확장 필요한가?
   └─ Sharding (Shard Key 신중히 선택!)
```

---

## 📊 기술별 비교 (한눈에)

| 특성 | Replication | Partitioning | Sharding | ORM | JDBC |
|------|-------------|--------------|----------|-----|------|
| **확장성** | 읽기만 ⭐⭐ | 제한적 ⭐⭐ | 무한 ⭐⭐⭐⭐⭐ | 자동화 ⭐⭐⭐ | 수동 ⭐ |
| **성능** | 빠름 ⭐⭐⭐⭐ | 중간 ⭐⭐⭐ | 복잡 ⭐⭐ | 중간 ⭐⭐⭐ | 매우빠름 ⭐⭐⭐⭐⭐ |
| **일관성** | 약함 ⭐⭐ | 강함 ⭐⭐⭐⭐⭐ | 약함 ⭐⭐ | 강함 ⭐⭐⭐⭐⭐ | 강함 ⭐⭐⭐⭐⭐ |
| **운영복잡도** | 중간 ⭐⭐⭐ | 낮음 ⭐⭐ | 높음 ⭐⭐⭐⭐⭐ | 낮음 ⭐⭐ | 높음 ⭐⭐⭐⭐ |
| **학습곡선** | 쉬움 | 중간 | 어려움 | 쉬움 | 중간 |

---
