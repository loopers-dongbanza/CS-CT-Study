# DP (Dynamic Programming)

## 정의
**문제를 작은 부분 문제로 나누고, 그 해를 이용해 전체 해를 구하는 방식**
- 중복되는 부분 문제를 저장해 계산량을 줄이는 알고리즘

---
## 특징
- 부분 문제의 최적해로 전체 최적해 구성
- Memoization (하향식) 또는 Tabulation (상향식)
- 한 번 계산한 부분 문제는 재계산 없음

---
## DP 풀이 구조 (4단계)
```
1. 상태 정의 (State)
   └─ dp[i][j] = ? 형태로 문제 표현

2. 점화식 (Transition)
   └─ 이전 상태로부터 현재 상태 유도
   └─ ex) dp[i] = dp[i-1] + dp[i-2]

3. 초기값 (Base Case)
   └─ dp[0], dp[1] 등 기본값 채우기

4. 계산 + 정답 (Compute)
   └─ 순차적으로 dp 채우고 마지막 값이 답
```

---
## 최적해 보장 조건 (필수 2가지)

### 1. 최적 부분 구조 (Optimal Substructure)
**전체 최적해 = 부분 문제의 최적해 조합**
- 큰 문제의 해가 작은 문제의 해로 구성됨
- 부분 문제를 최적으로 풀면 전체도 최적

### 2. 중복 부분 문제 (Overlapping Subproblems)
**같은 부분 문제가 반복되어 저장 의미 있음**
- 재귀로 풀면 같은 계산 여러 번
- 저장하면 시간 대폭 감소

⚠️ **둘 중 하나라도 깨지면 DP 불가!**

---
## 언제 사용하는가?

### ✅ 사용 가능 신호
- 이전 결과로 현재 결과 계산됨
- 전체 최적 = 부분 최적
- 경우의 수, 최적값(최대/최소), 경로 수
- "모든 경우 탐색은 너무 크고, 일정 패턴이 반복"

### ❌ 사용 불가 신호
- 현재 선택이 미래에 큰 영향을 줌 (그리디 판단과 유사)
- 상태 정의가 불가능
- 조합 폭발을 막을 규칙이 없음

---
## 대표 예제
- 피보나치
- 계단 오르기
- 배낭 문제 (0/1 Knapsack)
- LCS (Longest Common Subsequence)
- LIS (Longest Increasing Subsequence)
- 동전 문제

---
## 시간복잡도
- 대부분 **O(N), O(N²), O(N³)** 범위
- 점화식 크기에 따라 다름

---
## vs 다른 알고리즘

| | DP | Greedy | BFS/DFS |
| ------ | ---------- | -------------- | -------------- |
| 선택 | 모든 경우 비교 | 지금 최선만 | 조건에 따라 |
| 번복 | 가능 | 불가 | DFS만 가능 |
| 최적해 | ✅ 항상 | ⚠️ 조건부 | ❌ 보장 안함 |
| 시간복잡도 | 상태 수에 따라 | O(n log n) | O(V+E) |
| 상태 저장 | 필수 | 불필요 | 불필요 |

---
## 핵심 정리
1. **4단계**: 상태 → 점화식 → 초기값 → 계산
2. **2조건**: 최적 부분 구조 + 중복 부분 문제
4. **주의**: 상태 정의가 핵심!
