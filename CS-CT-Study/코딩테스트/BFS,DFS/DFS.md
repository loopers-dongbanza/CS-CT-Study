# DFS (Depth-First Search)

## 정의
**그래프를 깊게 파고 들어가는 탐색 방식**
- 재귀/스택 사용
- "모든 경우 탐색", "연결 요소 탐색"에 적합

---
## 특징
- 깊이 우선
- 백트래킹 가능
- 재귀로 구현 단순
- 사이클 주의 (visited 필수)

---
## 알고리즘 구조 (3단계)
```
1. 초기 선택 (Pick)
   └─ 시작 노드 선택

2. 확장 (Explore)
   └─ 방문 표시 → 인접 노드로 재귀 → 가지치기 적용

3. 종료 조건 (Backtrack)
   └─ 더 이상 갈 데 없으면 돌아옴
```

---
## 올바른 동작 조건 (필수 2가지)

### 1. 방문 추적 (Visited Tracking)
**이미 방문한 노드를 반드시 기록해야 함**
- visited[] 배열 필수
- 사이클 감지 및 무한 루프 방지
- 그래프에서 필수 (트리는 선택)

### 2. 명확한 탐색 목표 또는 가지치기
**목표 설정 또는 가지치기 조건 필요**
- 순수 탐색: 특정 노드/영역 찾기
- 백트래킹: 조건을 만족하는 경로만 탐색 (가지치기)
- 없으면 모든 경로 탐색 → O(V+E) 이상 소요

⚠️ **1번(visited)을 만족하지 않으면 무한 루프!**

---
## 언제 사용하는가?

### ✅ 사용 가능 신호
- 모든 경우(조합/경로) 탐색
- 백트래킹 기반 문제
- 사이클 탐지
- 연결 요소/영역 찾기

### ❌ 사용 불가 신호
- 최단 거리 필요 (→ BFS)
- 깊이 너무 깊어 StackOverflow 위험
- 가중치 있는 최단경로 (→ 다익스트라)

---
## 대표 예제
- 섬의 개수, 영역 크기
- 백트래킹 문제 (순열, 조합)
- 그래프 cycle detection
- 트리 DFS 순회

---
## 시간복잡도
- **그래프**: O(V + E)
- **백트래킹**: O(N!) (문제에 따라)

---
## vs 다른 알고리즘

| | DFS | BFS | DP |
| ------ | ---------- | -------------- | -------------- |
| 탐색 방식 | 깊이 우선 | 너비 우선 | 부분 문제 이용 |
| 자료구조 | Stack/재귀 | Queue | 메모이제이션 |
| 모든 경우 | ✅ | ❌ | ❌ |
| 최단거리 | ❌ | ✅ | ❌ |
| 백트래킹 | ✅ | ❌ | ❌ |
| 시간복잡도 | O(V+E) | O(V+E) | O(상태 수) |

---
## 핵심 정리
1. **재귀 기반**: 스택처럼 동작
2. **모든 경우 탐색**: 조합/경로 문제 최적
3. **백트래킹 적합**: 선택 후 복원 가능
4. **주의**: visited 필수! 깊이 주의!
